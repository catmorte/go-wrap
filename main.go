package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/printer"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"text/template"
	"unicode"

	"github.com/catmorte/go-stream/pkg/stream"
	. "github.com/catmorte/go-wrap/pkg/wrap"
	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

const (
	wrapPkgPath  = "github.com/catmorte/go-wrap/pkg/wrap"
	wrapPkgAlias = "goWrap"
	fileTemplate = `
// Code generated by "go-wrap_gen"; DO NOT EDIT.
package {{.PackageName}}
import (
{{range .Imports -}}
		{{if .Alias }} {{.Alias }} {{end -}}
		"{{.Path}}"
{{end -}}
)
{{if .PrintRaw}}
{{range .Funcs}}
{{.Code}}
{{end}}
{{ else}}
{{range .Funcs}}
func {{if .Receivers}}({{range .Receivers}}rcv {{.Code}}{{end}}){{end -}}
{{.Name}}Wrap({{range $index, $param := .Params}}{{if $index}}, {{end}}arg{{$index}} {{.Code}}{{end}}) {{"" -}} 
{{if eq (len .Results) 2 -}}
	{{$.WrapPackageAlias}}.Out[{{(index .Results 0).Code}}] {
	return {{$.WrapPackageAlias}}.Wrap({{if .Receivers}}{{range .Receivers}}rcv.{{end}}{{end}}{{.Name}}({{range $index, $param := .Params}}{{if $index}}, {{end}}arg{{$index}}{{if $param.Meta.IsVararg}}...{{end}} {{end}}))
{{- else if eq (len .Results) 1 -}}
	{{if eq (index .Results 0).Code "error" -}}
		{{$.WrapPackageAlias}}.Out[{{$.WrapPackageAlias}}.Empty] {
		return {{$.WrapPackageAlias}}.Void({{if .Receivers}}{{range .Receivers}}rcv.{{end}}{{end}}{{.Name}}({{range $index, $param := .Params}}{{if $index}}, {{end}}arg{{$index}}{{if $param.Meta.IsVararg}}...{{end}} {{end}}))
	{{- else -}}
		{{$.WrapPackageAlias}}.Out[{{(index .Results 0).Code}}] {
		return {{$.WrapPackageAlias}}.OK({{if .Receivers}}{{range .Receivers}}rcv.{{end}}{{end}}{{.Name}}({{range $index, $param := .Params}}{{if $index}}, {{end}}arg{{$index}}{{if $param.Meta.IsVararg}}...{{end}} {{end}}))
	{{- end }}
{{else if eq (len .Results) 0 -}}
	{{$.WrapPackageAlias}}.Out[{{$.WrapPackageAlias}}.Empty] {
	{{if .Receivers}}{{range .Receivers}}rcv.{{end}}{{end}}{{.Name}}({{range $index, $param := .Params}}{{if $index}}, {{end}}arg{{$index}}{{if $param.Meta.IsVararg}}...{{end}} {{end}})
	return {{$.WrapPackageAlias}}.OK({{$.WrapPackageAlias}}.Empty{})
{{- end }} 
}
{{end}}
{{end}}
`
)

type (
	Import struct {
		Alias string
		Path  string
	}
	Type[T any] struct {
		Code string
		Meta T
	}
	TypeMeta struct {
		Name string
	}
	ParamMeta struct {
		IsVararg bool
	}
	Func struct {
		Name      string
		Code      string
		Params    []*Type[ParamMeta]
		Results   []*Type[Empty]
		Types     []*Type[TypeMeta]
		Receivers []*Type[Empty]
	}
	File struct {
		Path    string
		Imports []*Import
		Funcs   []*Func
	}
	Package struct {
		Name   string
		Files  []*File
		Errors []*Error
	}
	Error struct {
		Message  string
		Position string
	}
)

func main() {
	file := os.Getenv("GOFILE")
	pathGot := Wrap(os.Getwd())

	var modes = map[string]func(int, *Func) bool{
		"public": func(i int, f *Func) bool {
			return unicode.IsUpper(rune(f.Name[0]))
		}, "private": func(i int, f *Func) bool {
			return unicode.IsLower(rune(f.Name[0]))
		}, "all": func(i int, s *Func) bool {
			return true
		},
	}

	var modeFilter func(int, *Func) bool
	var ok bool
	if len(os.Args) > 1 {
		mode := os.Args[1]
		modeFilter, ok = modes[mode]
		if !ok {
			log.Fatalf("unknown mode %v", mode)
		}
	} else {
		modeFilter = modes["all"]
	}

	errEx := regexp.MustCompile(`"(.+)" imported and not used`)

	And(pathGot, func(path string) Out[Empty] {
		fullPath := filepath.Join(path, file)
		packagesParsed := Parse(path)

		filesWritten := Each(packagesParsed, func(p *Package) Out[[]string] {
			filesStream := stream.New(p.Files...).Filter(func(i int, a *File) bool {
				return a.Path == fullPath
			})
			ensuredImport := Each(OKVargs(filesStream.Get()...), func(f *File) Out[*File] {
				f.Funcs = stream.New(f.Funcs...).Filter(modeFilter).Filter(func(i int, a *Func) bool {
					return len(a.Results) <= 1 || (len(a.Results) == 2 && a.Results[1].Code == "error")
				}).Get()

				importsStream := stream.New(f.Imports...)
				_, ok := importsStream.Filter(func(_ int, v *Import) bool {
					return v.Path == wrapPkgPath && v.Alias != "" && v.Alias != "_"
				}).First()
				if !ok {
					i := 0
					alias := ""
					for {
						alias = fmt.Sprintf("%s%d", wrapPkgAlias, i)
						_, ok = importsStream.Filter(func(_ int, v *Import) bool {
							return v.Alias == alias
						}).First()
						if !ok {
							f.Imports = append(f.Imports, &Import{Alias: alias, Path: wrapPkgPath})
							break
						}
						i++
					}
				}
				return OK(f)
			})
			return JoinAsync(EachAsync(ensuredImport, func(f *File) Out[string] {
				codeGenerated := Generate(p.Name, *f, false)
				return And(codeGenerated, func(raw []byte) Out[string] {
					fileName := fmt.Sprintf("%s_wrap.go", strings.TrimSuffix(file, filepath.Ext(file)))
					fullPath := filepath.Join(path, fileName)
					return Wrap(fullPath, os.WriteFile(fullPath, raw, 0644))
				})
			}))
		})
		filesFixed := EachAsync(Flat(filesWritten), func(fullPath string) Out[[]string] {
			packagesParsed := Parse(path)
			filesFixed := (EachAsync(packagesParsed, func(p *Package) Out[[]string] {
				errorsStream := stream.New(p.Errors...)
				fixedFilesStream := stream.Wrap(stream.New(p.Files...), func(i int, f *File) []*File {
					if f.Path != fullPath {
						return nil
					}
					relatedErrorsStream := errorsStream.Filter(func(_ int, e *Error) bool {
						return strings.HasPrefix(e.Position, f.Path)
					})
					unusedDotPackages := stream.Wrap(relatedErrorsStream, func(_ int, e *Error) []string {
						subMatches := errEx.FindStringSubmatch(e.Message)
						if len(subMatches) == 0 {
							return nil
						}
						return subMatches[1:]
					})
					if unusedDotPackages.Count() == 0 {
						return nil
					}
					f.Imports = stream.New(f.Imports...).Filter(func(_ int, i *Import) bool {
						if i.Alias != "." {
							return true
						}
						_, _, ok := unusedDotPackages.FirstBy(func(_ int, p string) bool {
							return i.Path == p
						})
						return !ok
					}).Get()
					return []*File{f}
				})
				return JoinAsync(EachAsync(OKVargs(fixedFilesStream.Get()...), func(f *File) Out[string] {
					codeGenerated := Generate(p.Name, *f, true)
					return And(codeGenerated, func(raw []byte) Out[string] {
						return Wrap(fullPath, os.WriteFile(fullPath, raw, 0644))
					})
				}))
			}))
			return JoinAsync(Flat(filesFixed))
		})
		return ProofAsync(JoinAsync(filesFixed))
	}).IfError(func(err error) {
		log.Fatal(err)
	})
}

func Parse(path string) []Out[*Package] {
	cfg := &packages.Config{
		Mode:  packages.NeedExportFile | packages.NeedModule | packages.NeedName | packages.NeedDeps | packages.NeedTypesInfo | packages.NeedSyntax | packages.NeedTypes | packages.NeedImports | packages.NeedFiles,
		Dir:   ".",
		Env:   os.Environ(),
		Tests: false,
	}

	packagesLoaded := DisJoin(Wrap(packages.Load(cfg, path+"/...")))
	return Each(packagesLoaded, func(p *packages.Package) Out[*Package] {
		filesDisJoined := DisJoin(OK(p.Syntax))
		errorsParsed := Each(OKVargs(p.Errors...), func(err packages.Error) Out[*Error] {
			return OK(&Error{
				Message:  err.Msg,
				Position: err.Pos,
			})
		})

		filesParsed := EachAsync(filesDisJoined, func(f *ast.File) Out[*File] {
			declsStream := stream.New(f.Decls...)
			astFuncStream := stream.FilterByType[ast.Decl, *ast.FuncDecl](declsStream)
			funcsConverted := EachAsync(OKVargs(astFuncStream.Get()...), func(fn *ast.FuncDecl) Out[*Func] {
				getCodeFromPos := func(fset *token.FileSet, node any) string {
					b := new(bytes.Buffer)
					printer.Fprint(b, fset, node)
					return b.String()
				}
				fieldListToStream := func(l *ast.FieldList) stream.Stream[*ast.Field] {
					if l == nil {
						return stream.New[*ast.Field]()
					}
					return stream.New(l.List...)
				}
				fieldToType := func(fset *token.FileSet) func(i int, f *ast.Field) *Type[Empty] {
					return func(i int, f *ast.Field) *Type[Empty] {
						return &Type[Empty]{Code: getCodeFromPos(fset, f.Type)}
					}
				}
				fieldToTypeParam := func(fset *token.FileSet) func(i int, f *ast.Field) *Type[ParamMeta] {
					return func(i int, f *ast.Field) *Type[ParamMeta] {
						code := getCodeFromPos(fset, f.Type)
						return &Type[ParamMeta]{
							Code: code,
							Meta: ParamMeta{
								IsVararg: strings.HasPrefix(code, "..."),
							},
						}
					}
				}
				fieldToTypeTypeArg := func(fset *token.FileSet) func(i int, f *ast.Field) *Type[TypeMeta] {
					return func(i int, f *ast.Field) *Type[TypeMeta] {
						return &Type[TypeMeta]{
							Code: getCodeFromPos(fset, f.Type),
							Meta: TypeMeta{
								Name: f.Names[0].Name,
							},
						}
					}
				}

				return OK(&Func{
					Name:      fn.Name.Name,
					Code:      getCodeFromPos(p.Fset, fn),
					Params:    stream.Wrap1to1(fieldListToStream(fn.Type.Params), fieldToTypeParam(p.Fset)).Get(),
					Receivers: stream.Wrap1to1(fieldListToStream(fn.Recv), fieldToType(p.Fset)).Get(),
					Results:   stream.Wrap1to1(fieldListToStream(fn.Type.Results), fieldToType(p.Fset)).Get(),
					Types:     stream.Wrap1to1(fieldListToStream(fn.Type.TypeParams), fieldToTypeTypeArg(p.Fset)).Get(),
				})
			})

			fullPath := p.Fset.Position(f.Pos()).Filename
			importsProcessed := EachAsync(OKVargs(f.Imports...), func(v *ast.ImportSpec) Out[*Import] {
				pathUnquoted := Wrap(strconv.Unquote(v.Path.Value))
				return And(pathUnquoted, func(path string) Out[*Import] {
					alias := ""
					if v.Name != nil {
						alias = v.Name.String()
					}
					return OK(&Import{Path: path, Alias: alias})
				})
			})
			funcsJoined := JoinAsync(funcsConverted)
			importsJoined := JoinAsync(importsProcessed)
			allGood := Proof(funcsJoined, importsJoined)
			return And(allGood, func(Empty) Out[*File] {
				funcs := funcsJoined.GetOrDefault(nil)
				imports := importsJoined.GetOrDefault(nil)
				return OK(&File{
					Path:    fullPath,
					Funcs:   funcs,
					Imports: imports,
				})
			})
		})
		errorsJoined := Join(errorsParsed)
		filesJoined := Join(filesParsed)
		allGood := Proof(errorsJoined, filesJoined)

		return And(allGood, func(Empty) Out[*Package] {
			files := filesJoined.GetOrDefault(nil)
			errors := errorsJoined.GetOrDefault(nil)
			return OK(&Package{
				Files:  files,
				Name:   p.Name,
				Errors: errors,
			})
		})
	})
}

func Generate(packageName string, f File, printRaw bool) Out[[]byte] {
	type fileTemplateData struct {
		PackageName      string
		WrapPackageAlias string
		PrintRaw         bool
		File
	}
	wrapPkg, _ := stream.New(f.Imports...).Filter(func(_ int, i *Import) bool {
		return i.Path == wrapPkgPath && i.Alias != "_" && i.Alias != ""
	}).First()

	templateParsed := Wrap(template.New("fileTemplate").Parse(fileTemplate))
	return And(templateParsed, func(t *template.Template) Out[[]byte] {
		buf := new(bytes.Buffer)
		templateExecuted := Void(t.Execute(buf, fileTemplateData{
			PackageName:      packageName,
			File:             f,
			WrapPackageAlias: wrapPkg.Alias,
			PrintRaw:         printRaw,
		}))
		return And(templateExecuted, func(Empty) Out[[]byte] {
			codeFormatted := Wrap(format.Source(buf.Bytes()))
			return And(codeFormatted, func(bytes []byte) Out[[]byte] {
				return Wrap(imports.Process("", bytes, nil))
			})
		})
	})
}
